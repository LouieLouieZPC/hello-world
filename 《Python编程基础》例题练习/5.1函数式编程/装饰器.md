# 装饰器

[参考网站](https://www.runoob.com/w3cnote/python-func-decorators.html)

**看代码要从左到右，从上到下，一层一层看，从第一层的定义声明、返回到第二层的定义声明、返回**

**python中装饰器做的事情：它们封装一个函数，并且用这样或者那样的方式来修改它的行为，装饰器让你在一个函数的前后去执行代码。在代码运行期间动态增加功能。  
本质上：decorator（装饰器）就是一个返回函数的高阶函数**

## 一、装饰器基础

**一切皆可对象，函数也是个对象，函数对象被赋值给变量，也可从函数中返回函数，甚至将函数作为参数传给另一个函数：**

```python
def now():
    print('2020.2.10')
f=now     # 一切皆可对象，函数也是个对象，函数对象被赋值给变量
f()       # 调用该函数
```
**利用__name__属性，可以拿到函数的名字：**
```python
print(now.__name__)   
print(f.__name__)    # __name__属性，拿到函数的名字
now
```


## 二、装饰器的蓝本
```python
from functools import wraps      # 装饰器会重写被装饰函数的名字和注释文档(docstring)，有些依赖函数签名的代码执行就会出错，当用__name__属性查看函数名字会变成装饰器中的函数名。可用functools.wraps解决这一问题
def decorator_name(f):   # 装饰器，它的参数为function即函数
    @wraps(f)        # 用@来包裹被修饰的函数
    def decorated(*args, **kwargs):  # 参数定义是(*args, **kw)，因此，decorated()函数可以接受任意参数的调用
        if not can_run:
            return "Function will not run"  # return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。
        return f(*args, **kwargs)   # 返回调用被修饰函数
    return decorated
 
@decorator_name   # 借助Python的@语法，把decorator置于函数的定义处
def func():     # 此处func()为被修饰函数
    return("Function is running")
 
can_run = True
print(func())
# Output: Function is running
 
can_run = False
print(func())
# Output: Function will not run

print(func.__name__)
# Output:func     __name__属性，拿到函数的名字.由于functools.wraps的帮助名字无问题
```

**如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数:**
```python
import functools   # 导入functools模块

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

@log('execute')
def now():
    print('2020-2-10')

>>> now()
execute now():
2020-2-10
```


************************************




# 二、闭包

**一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包(closure)**

## （一）注意：

**返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。例如：**  
