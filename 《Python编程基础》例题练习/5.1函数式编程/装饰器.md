# 装饰器

[参考网站](https://www.runoob.com/w3cnote/python-func-decorators.html)

**看代码要从左到右，从上到下，一层一层看，从第一层的定义声明、返回到第二层的定义声明、返回**

**python中装饰器做的事情：它们封装一个函数，并且用这样或者那样的方式来修改它的行为，装饰器让你在一个函数的前后去执行代码**

## 一、装饰器基础
```python
def now():
    print('2020.2.10')
f=now     # 函数也是个对象，函数对象被赋值给变量
f()       # 调用该函数
```
**利用__name__属性，可以拿到函数的名字**
```python
print(now.__name__)   
print(f.__name__)    # __name__属性，拿到函数的名字
now
```


## 二、装饰器的规范写法
```python
from functools import wraps      # 装饰器会重写被装饰函数的名字和注释文档(docstring)， 当用__name__属性查看函数名字会变成装饰器中的函数名。可用functools.wraps解决这一问题
def decorator_name(f):
    @wraps(f)        # 用@来包裹被修饰的函数
    def decorated(*args, **kwargs):  # 参数定义是(*args, **kw)，因此，decorated()函数可以接受任意参数的调用
        if not can_run:
            return "Function will not run"
        return f(*args, **kwargs)   # 返回调用被修饰函数
    return decorated
 
@decorator_name
def func():     # 此处func()为被修饰函数
    return("Function is running")
 
can_run = True
print(func())
# Output: Function is running
 
can_run = False
print(func())
# Output: Function will not run
```














************************************


# 二、闭包

**一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包(closure)**

## （一）注意：

**返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。例如：**  
