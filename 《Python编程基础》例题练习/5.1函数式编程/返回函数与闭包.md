# 返回函数和闭包

# 一、把函数作为返回值：

```python
def lazy_sum(*args):
    def sum():           # 通常情况下，无需这一列，但如果不需要立刻求和，可以不返回求和的结果，而是返回求和的函数
        for n in args:
            ax=ax+0
        return ax
    return sum
```

当我们调用`lazy_sum()`时，返回的并不是**求和结果**，而是**求和函数**：

```python
>>> f = lazy_sum(1, 3, 5, 7, 9)
>>> f
<function lazy_sum.<locals>.sum at 0x101c6ed90>
```

调用函数f时，才真正计算求和的结果：

```python
>>> f()
25
```

**“闭包（Closure）”程序结构:**  
在函数`lazy_sum`中又定义了函数`sum`，  
内部函数`sum`可以引用外部函数`lazy_sum`的参数和局部变量`args`  
当`lazy_sum`返回函数`sum`时，相关参数和变量都保存在返回的函数中

# 二、闭包

## 注意：

**返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。例如：**  

>```python
>def count():   # 第一层函数
>    fs = []    # 定义一个空列表
>    for i in range(1, 4):     # 循环变量i
>        def f():    # 第二层函数
>             return i*i       # 第二层函数返回引用了循环变量！！！
>        fs.append(f)
>    return fs
>
>f1, f2, f3 = count()
>```

实际结果是：全都是9！  
原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。
>```python
>>>> f1()  # 不加括号返回的是函数，加了才是调用函数的结果
>9
>>>> f2()
>9
>>>> f3()
>9
>```

## 不得已下：

如果**一定要引用循环变量：**   
再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：


```python
def count():
    def f(j):     # 第二层函数用它的参数绑定循环变量的值i！
        def g():  # 第三层函数引用了循环变量
            return j*j   # 第三层函数返回中引用了循环变量的值
        return g  # 第二层函数返回第三层函数
    fs = []       # 定义一个空列表
    for i in range(1, 4):    # 和第二层函数平级
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs     # 第一层函数返回结果
```


以下为结果：

再看看结果：
```python
>>> f1, f2, f3 = count()
>>> f1()
1
>>> f2()
4
>>> f3()
9
```