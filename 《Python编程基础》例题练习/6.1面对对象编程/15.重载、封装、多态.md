# 重载
**子类中的方法会覆盖父类中同名的方法**

```python
class Cat:
    def sayHello(self):
        print('mua------1')
class Bosi(Cat):
    def sayHello(self):
        print('mua------2')
Bosi=Bosi()
Bosi.sayHello()
'''
以上结果如下：
mua------2
'''
```

*************************************************

# 封装

通过设置好的接口函数来访问对象原理：
面向对象编程的一个重要特点就是数据封装。
既然Cat实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Cat类的内部定义访问数据的函数，
这样，就把“数据”给封装起来了。这些封装数据的函数是Cat类本身是关联起来的，我们称之为类的方法

```python
class Cat():
    def __init__(self,name,age):      # __init__是特殊变量，特殊变量是可以直接访问的,不是private变量
        self._name=name
        self._age=age
    def sleep(self):           # 设置接口函数，封装
        print('%d岁的%s正在沙发上睡懒觉。'%(self._age,self._name))  
    def eat(self,food):        # 设置接口函数，封装
        self._food=food
        print('%d岁的%s正在吃%s。'%(self._age,self._name,self._food))
    def getAttribute(self):    # 设置接口函数，封装
        return self._name,self._age
cat1=Cat('Tom',3)      # 创建对象，输入参数
cat2=Cat('Jack',4)     # 创建对象，输入参数
print('Cat1的名字为：',cat1.name)         # 私有化后从外部访问对象的属性会发现访问不了
Traceback (most recent call last):      
  File "d:/01.Software/GitHub/GitHub Repository/hello-world/《Python编程基础》例题练习/5.1面对对象编程/6.对类的数据属性和方法进行私有化.py", line 23, in <module>
    print('Cat1的名字为：',cat1.name)
AttributeError: 'Cat' object has no attribute 'name'
print(cat1.sleep())           # 只能通过设置好的接口函数来访问对象
# 结果为：3岁的Tom正在沙发上睡懒觉。
print(cat2.eat('fish'))       # 只能通过设置好的接口函数来访问对象
# 结果为：4岁的Jack正在吃fish。
print(cat1.getAttribute())    # 只能通过设置好的接口函数来访问对象
# 结果为：('Tom',3)
```


***************************************************


# 多态

当子类和父类都存在相同的函数方法时，子类的函数方法覆盖了父类的函数方法，在代码运行的时候，总是会调用子类的函数方法。这样，我们就获得了继承的另一个好处：多态。

当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：

```python
class Animal(object):
    def run(self):
        print('Animal is running...')

class Dog(Animal):

    def run(self):
        print('Dog is running...')

class Cat(Animal):

    def run(self):
        print('Cat is running...')
```
