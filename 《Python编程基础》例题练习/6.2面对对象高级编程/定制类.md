# 定制类

## 一、通过在类中定义`__str__/__repr__`，实现输入s()/s时的显示内容

> \_\_str__()返回用户看到的字符串  
> 而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的

调用 print(i1)  （#等同与print(str(i1))）的时候，解释器第一个寻找的就是i1这个类的方法里面有没有重新定义str，如果没有，那么它第二步会去寻找这个类里面有没有重新定义repr，如果有则会用类方法的repr，如果还没有，那么解释器会找这个类的上一层父类，object里面定义了str和repr，object是一切类的父类，所以输出的对象一定会是渲染过的。若这个类里面自己写了str和repr，它覆盖了object里面的str和repr，相当于print的重定向。按同样的规则进行寻找，直到最后找到了object，然后用object的str方法，将该对象的内容转成字符串，最后输出到终端。

调用print（repr（i1））的时候就不一样了，repr只会调用repr方法，当自定义的类中没有重写repr方法的时候，它会直接找上一级的父类中有没有repr方法，而不会考虑调用str方法。


```python
class Test(object):
    def __init__(self, value='hello, world!'):
        self.data = value

>>> t = Test()
>>> t
<__main__.Test at 0x7fa91c307190>
>>> print t
<__main__.Test object at 0x7fa91c307190>

# 上面打印类对象并不是很友好，显示的是对象的内存地址
# 下面我们重构下该类的__repr__以及__str__，看看它们俩有啥区别

# 1.重构__repr__
class TestRepr(Test):
    def __repr__(self):
        return 'TestRepr(%s)' % self.data

>>> tr = TestRepr()
>>> tr
TestRepr(hello, world!)
>>> print tr
TestRepr(hello, world!)

# 重构__repr__方法后，不管直接输出对象还是通过print打印的信息都按我们__repr__方法中定义的格式进行显示了

# 2.重构__str__
calss TestStr(Test):
    def __str__(self):
        return '[Value: %s]' % self.data

>>> ts = TestStr()
>>> ts
<__main__.TestStr at 0x7fa91c314e50>
>>> print ts
[Value: hello, world!]

# 你会发现，直接输出对象ts时并没有按我们__str__方法中定义的格式进行输出，而用print输出的信息却改变了


# 3.使用__repr__=__str__
>>> class Test(object):
...     def __init__(self, value='hello, world!'):
...         self.data = value
...     def __str__(self):
...         return '[Value: %s]' % self.data
...
>>> ts =Test()
>>> ts
<__main__.Test object at 0x0000026AE4DB8AC8>
>>> print(ts)
[Value: hello, world!]
>>> class Test(object):
...     def __init__(self, value='hello, world!'):
...         self.data = value
...     def __str__(self):
...         return '[Value: %s]' % self.data
...     __repr__=__str__
...
>>> ts =Test()
>>> ts
[Value: hello, world!]
>>> print(ts)
[Value: hello, world!]

```










## 二、通过在类中定义`__iter__`，将类变为可迭代的对象

如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。

```python
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
# 现在，试试把Fib实例作用于for循环：
# 1.方法一
s=Fib()          #创建类对象
>>> for n in s:
...     print(n)
...
1
1
2
3
5
...
46368
75025

# 2.方法二
s=Fib()               # 创建类对象
iterator=iter(s)       # 将类对象变成可迭代对象（（迭代器）（正规写法）
for n in iterator:
  print(n)
1
1
2
3
5
...
46368
75025
```













## 三、通过在类中定义`__getitem__`，将类变为具有list特性的对象，即可通过下标和切片获取元素

`__getitem__()`的参数也可能是一个可以作key的object，例如`str`。  
`__setitem__()`方法，把对象视作list或dict来对集合赋值。  
`__delitem__()`方法，用于删除某个元素。


```python
class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片,slice
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x >= start:
                    L.append(a)
                a, b = b, a + b
            return L
>>> f = Fib()     # 创建类对象
>>> f[3]          # 获取元素
3
>>> f[0:5]        # 对类对象切片
[1, 1, 2, 3, 5]
>>> f[:10]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
```









## 四、通过在类中定义`__getattr__`，可以动态化处理类的属性和方法的调用。












## 五、通过在类中定义`__call__`，可以实现利用实例本身来调用方法，即输入s()执行调用