# 定制类

## 一、通过在类中定义__str__/__repr__，实现输入s()/s时的显示内容

> \_\_str__()返回用户看到的字符串  
> 而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的

调用 print(i1)  （#等同与print(str(i1))）的时候，解释器第一个寻找的就是i1这个类的方法里面有没有重新定义str，如果没有，那么它第二步会去寻找这个类里面有没有重新定义repr，如果有则会用类方法的repr，如果还没有，那么解释器会找这个类的上一层父类，object里面定义了str和repr，object是一切类的父类，所以输出的对象一定会是渲染过的。若这个类里面自己写了str和repr，它覆盖了object里面的str和repr，相当于print的重定向。按同样的规则进行寻找，直到最后找到了object，然后用object的str方法，将该对象的内容转成字符串，最后输出到终端。

调用print（repr（i1））的时候就不一样了，repr只会调用repr方法，当自定义的类中没有重写repr方法的时候，它会直接找上一级的父类中有没有repr方法，而不会考虑调用str方法。


```python
class Test(object):
    def __init__(self, value='hello, world!'):
        self.data = value

>>> t = Test()
>>> t
<__main__.Test at 0x7fa91c307190>
>>> print t
<__main__.Test object at 0x7fa91c307190>

# 上面打印类对象并不是很友好，显示的是对象的内存地址
# 下面我们重构下该类的__repr__以及__str__，看看它们俩有啥区别

# 1.重构__repr__
class TestRepr(Test):
    def __repr__(self):
        return 'TestRepr(%s)' % self.data

>>> tr = TestRepr()
>>> tr
TestRepr(hello, world!)
>>> print tr
TestRepr(hello, world!)

# 重构__repr__方法后，不管直接输出对象还是通过print打印的信息都按我们__repr__方法中定义的格式进行显示了

# 2.重构__str__
calss TestStr(Test):
    def __str__(self):
        return '[Value: %s]' % self.data

>>> ts = TestStr()
>>> ts
<__main__.TestStr at 0x7fa91c314e50>
>>> print ts
[Value: hello, world!]

# 你会发现，直接输出对象ts时并没有按我们__str__方法中定义的格式进行输出，而用print输出的信息却改变了


# 3.使用__repr__=__str__
>>> class Test(object):
...     def __init__(self, value='hello, world!'):
...         self.data = value
...     def __str__(self):
...         return '[Value: %s]' % self.data
...
>>> ts =Test()
>>> ts
<__main__.Test object at 0x0000026AE4DB8AC8>
>>> print(ts)
[Value: hello, world!]
>>> class Test(object):
...     def __init__(self, value='hello, world!'):
...         self.data = value
...     def __str__(self):
...         return '[Value: %s]' % self.data
...     __repr__=__str__
...
>>> ts =Test()
>>> ts
[Value: hello, world!]
>>> print(ts)
[Value: hello, world!]

```










## 二、通过在类中定义__iter__，将类变为可迭代的对象

如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。






## 三、通过在类中定义__getitem__，将类变为具有list特性的对象，即可通过下标和切片获取元素







## 四、通过在类中定义__getattr__，可以动态化处理类的属性和方法的调用。












## 五、通过在类中定义__call__，可以实现利用实例本身来调用方法，即输入s()执行调用