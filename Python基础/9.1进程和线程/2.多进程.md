# 多进程(multiprocessing)(在Windows上实现)

操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回
子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。


##一、创建并启动一个子进程并等待其结束

- `multiprocessing模块`中的`Process类`来代表一个进程对象  
- `os.getpid()`：得到进程标识符  
- 用`start()`启动子进程  
- `join()`方法：可以等待子进程结束后再继续往下运行，通常用于进程间的同步  


```python
from multiprocessing import Process
import os

# 启动一个子进程并等待其结束

# 创建子进程（创建子进程时，只需要传入一个执行函数和函数的参数）
def run_proc(name):
    print('Run child process %s(%s)'%(name,os.getpid()))   # `os.getpid()`：得到进程标识符  

if __name__ == "__main__":
    print('Parent process %s.'%os.getpid())
    p=Process(target=run_proc,args=('test',))   # 创建一个Process实例，target为子程序，则p为子程序的对象； args=()是一个元组,被传给子进程
    print('Child process will start.')
    p.start()  # 启动子程序
    p.join()   # 等待子进程结束后再继续往下运行
    print('Child process end.')

'''
#Output：
Parent process 2396.
Child process will start.
Run child process test(6340)
Child process end.
'''
```


## 二、创建并启动大量的子进程并等待其结束

用`进程池`的方式批量创建子进程:  
使用`multiprocessing模块`中的`Pool类`


```python
from multiprocessing import Pool
import os,time,random    # 导入os、time、random模块

def long_time_task(name):
    print('Run task %s(%s)'%(name,os.getpid()))
    start=time.time()       # time.time() 返回当前时间的时间戳（1970纪元后经过的浮点秒数）。
    time.sleep(random.random()*3)        # time sleep(secs) 函数推迟调用线程的运行，可通过参数secs指秒数，表示进程挂起的时间。;random() 方法返回随机生成的一个实数，它在[0,1)范围内
    end=time.time()         #
    print('Task %s runs %0.2f seconds.'%(name,(end-start)))   # %0.2f为round（）四舍五入后保留两位小数

if __name__ == "__main__":
    print('Parent process %s.'%os.getpid())
    p=Pool(4)   # 这里设定了可同时跑4个进程，若改成p = Pool(5)则可同时跑5个进程；Pool的默认大小是本电脑CPU的核数
    for i in range(5):
        p.apply_async(long_time_task,args=(i,))
    print('Waiting for all subprocesses done...')
    p.close()  # 调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了
    p.join()  # 对Pool对象调用join()方法会等待所有子进程执行完毕
    print('All subprocesses done.')


'''
# Output:
Parent process 17812.
Waiting for all subprocesses done...
Run task 0(17100)
Run task 1(19100)
Run task 2(17320)
Run task 3(18472)
Task 0 runs 0.42 seconds.
Run task 4(17100)
Task 2 runs 1.86 seconds.
Task 4 runs 1.60 seconds.
Task 3 runs 2.09 seconds.
Task 1 runs 2.66 seconds.
All subprocesses done.
'''
```

