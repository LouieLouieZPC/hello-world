# 多进程(multiprocessing)(在Windows上实现)

操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回
子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。



本章运用:  
* 1.`multiprocessing`模块：  
  * `process`类：创建并启动一个子进程的实例  
  *  `Pool`类：以`进程池`的方式批量创建子进程  
  
* 2.`os`模块:
  * `os.getpid()`方法：得到自身的进程标识符   

* 3.`time`模块:  
  * 

* 4.`random`模块:  
  * 












## 一、创建并启动一个子进程并等待其结束

- `multiprocessing模块`中的`Process类`来代表一个进程对象，在`process类的对象`中：  
  - `start()`方法启动子进程  
  - `join()`方法：可以等待子进程结束后再继续往下运行，通常用于进程间的同步  
- 在`os模块中`:  
  - `os.getpid()`方法：得到自身的进程标识符  



```python
from multiprocessing import Process
import os

# 启动一个子进程并等待其结束

# 创建子进程（创建子进程时，只需要传入一个执行函数和函数的参数）
def run_proc(name):
    print('Run child process %s(%s)'%(name,os.getpid()))   # `os.getpid()`：得到进程标识符  

if __name__ == "__main__":
    print('Parent process %s.'%os.getpid())
    p=Process(target=run_proc,args=('test',))   # 创建一个Process实例，target为子程序，则p为子程序的对象； args=()是一个元组,被传给子进程
    print('Child process will start.')
    p.start()  # 启动子程序
    p.join()   # 等待子进程结束后再继续往下运行
    print('Child process end.')

'''
#Output：
Parent process 2396.
Child process will start.
Run child process test(6340)
Child process end.
'''
```


## 二、创建并启动大量的子进程并等待其结束

用`进程池`的方式批量创建子进程:  
- 使用`multiprocessing模块`中的`Pool类`


```python
from multiprocessing import Pool
import os,time,random    # 导入os、time、random模块

# 创建子进程
def long_time_task(name):
    print('Run task %s(%s)'%(name,os.getpid()))
    start=time.time()       # time.time() 返回当前时间的时间戳（1970纪元后经过的浮点秒数）。
    time.sleep(random.random()*3)        # time sleep(secs) 函数推迟调用线程的运行，可通过参数secs指秒数，表示进程挂起的时间。;random() 方法返回随机生成的一个实数，它在[0,1)范围内
    end=time.time()         #
    print('Task %s runs %0.2f seconds.'%(name,(end-start)))   # %0.2f效果同于round（），四舍五入后保留两位小数

if __name__ == "__main__":
    print('Parent process %s.'%os.getpid())
    p=Pool(4)   # 创建类的实例，这里设定了可同时跑4个进程，若改成p = Pool(5)则可同时跑5个进程；Pool的默认大小是本电脑CPU的核数
    for i in range(5):
        p.apply_async(long_time_task,args=(i,))  # 进程池.apply_async()方法，异步非阻塞式，不用等待当前进程执行完毕，随时跟进操作系统调度来进行进程切换。进程0没有执行完，就切换到进程1开始执行，进程1没有执行完，就切换到进程2，然后在切换回去。等待所有子进程运行完毕后，最后切换回主进程，执行剩余部分
    print('Waiting for all subprocesses done...')
    p.close()  # 调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了
    p.join()  # 对Pool对象调用join()方法会等待所有子进程执行完毕
    print('All subprocesses done.')


'''
# Output:
Parent process 17812.
Waiting for all subprocesses done...
Run task 0(17100)
Run task 1(19100)
Run task 2(17320)
Run task 3(18472)
Task 0 runs 0.42 seconds.
Run task 4(17100)
Task 2 runs 1.86 seconds.
Task 4 runs 1.60 seconds.
Task 3 runs 2.09 seconds.
Task 1 runs 2.66 seconds.
All subprocesses done.
'''
```

因为.Pool()方法的设定大小是4，因此，最多同时执行4个进程，  
所以在输出的结果中，task 4要等待前面某个task完成后才执行  


## 三、创建和启动一个子进程，并控制其输入和输出）

利用`subprocess模块`和模块中的call类


```python
import subprocess

print('$ nslookup www.python.org')
r=subprocess.call(['nslookup','www.python.org'])
print('Exit code:',r)

'''
# Output:
$ nslookup www.python.org
服务器:  UnKnown
Address:  192.168.101.1

非权威应答:
名称:    dualstack.python.map.fastly.net
Addresses:  2a04:4e42:36::223
          151.101.108.223
Aliases:  www.python.org
'''
```





